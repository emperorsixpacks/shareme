{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-87d674ef32813db46f96f5f10d09c69b0df1f532",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SmartWallet.sol": "project/contracts/SmartWallet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SmartWallet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nstruct CreatorSpace {\n    bytes32 spaceId;\n    address wallet;\n}\n\nstruct CreatorWallets {\n    CreatorSpace[] spaces;\n}\n\nlibrary CreatorWalletsLib {\n    function addSpace(\n        CreatorWallets storage self,\n        bytes32 spaceId,\n        address wallet\n    ) internal {\n        self.spaces.push(CreatorSpace({spaceId: spaceId, wallet: wallet}));\n    }\n\n    function getSpaceById(\n        CreatorWallets storage self,\n        bytes32 spaceId\n    ) internal view returns (CreatorSpace storage) {\n        for (uint256 i = 0; i < self.spaces.length; i++) {\n            if (self.spaces[i].spaceId == spaceId) {\n                return self.spaces[i];\n            }\n        }\n        revert(\"Space not found\");\n    }\n\n    function hasSpace(\n        CreatorWallets storage self,\n        bytes32 spaceId\n    ) internal view returns (bool) {\n        for (uint256 i = 0; i < self.spaces.length; i++) {\n            if (self.spaces[i].spaceId == spaceId) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ninterface ISmartWalletFactory {\n    function getPlatformFee() external view returns (uint256);\n    function getPlatformWallet() external view returns (address);\n    function isAllowedAsset(address token) external view returns (bool);\n}\n\ncontract SmartWallet {\n    address private controller;\n    address public creator;\n    address public creatorToken;\n    bool public allowOnlyCreatorToken;\n\n    ISmartWalletFactory public factory;\n\n    event PaymentReceived(address sender, uint amount);\n    event PaymentSplit(address creator, uint creatorAmount, uint platformAmount);\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"Not controller\");\n        _;\n    }\n\n    constructor(\n        address _controller,\n        address _creator,\n        address _factory\n    ) {\n        controller = _controller;\n        creator = _creator;\n        factory = ISmartWalletFactory(_factory);\n        allowOnlyCreatorToken = false;\n    }\n\n    /// Toggle creator token restriction\n    function allowOnlyCreatorTokenOff() external onlyController {\n        allowOnlyCreatorToken = false;\n    }\n\n    function setCreatorToken(address tokenAddress) external onlyController {\n        require(tokenAddress != address(0), \"Invalid address\");\n        creatorToken = tokenAddress;\n    }\n\n    function getCreatorToken() external view returns (address) {\n        require(creatorToken != address(0), \"Creator token not set\");\n        return creatorToken;\n    }\n\n    /// Forward token payments\n    function forwardTransfer(address token, uint256 amount, address initiator) external onlyController {\n        require(factory.isAllowedAsset(token), \"Token not allowed\");\n        require(amount > 0, \"No payment\");\n\n        uint256 platformFee = factory.getPlatformFee();\n        uint256 platformAmount = (amount * platformFee) / 100;\n        uint256 creatorAmount = amount - platformAmount;\n\n        require(IERC20(token).transfer(creator, creatorAmount), \"Creator transfer failed\");\n        require(IERC20(token).transfer(factory.getPlatformWallet(), platformAmount), \"Platform transfer failed\");\n\n        emit PaymentReceived(initiator, amount);\n        emit PaymentSplit(creator, creatorAmount, platformAmount);\n    }\n\n    receive() external payable {\n        uint256 platformFee = factory.getPlatformFee();\n        uint256 platformAmount = (msg.value * platformFee) / 100;\n        uint256 creatorAmount = msg.value - platformAmount;\n\n        payable(creator).transfer(creatorAmount);\n        payable(factory.getPlatformWallet()).transfer(platformAmount);\n\n        emit PaymentReceived(msg.sender, msg.value);\n        emit PaymentSplit(creator, creatorAmount, platformAmount);\n    }\n}\n\ncontract SmartWalletFactory {\n    address public platformWallet;\n    address private controller;\n\n    using CreatorWalletsLib for CreatorWallets;\n    mapping(address => CreatorWallets) private creatorWallets;\n    mapping(address => address) public walletToCreator;\n    mapping(address => bool) public allowedAssets;\n    uint256 public platformFee; \n\n    event WalletCreated(address indexed creator, address wallet);\n    event AllowedAssetAdded(address token);\n    event AllowedAssetRemoved(address token);\n    event PlatformFeeUpdated(uint256 newFee);\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"Not controller\");\n        _;\n    }\n\n    constructor(address _platformWallet) {\n        platformWallet = _platformWallet;\n        controller = msg.sender;\n    }\n\n    function createWallet(bytes32 spaceID) external returns (address) {\n        CreatorWallets storage cw = creatorWallets[msg.sender];\n        require(!cw.hasSpace(spaceID), \"Space already exists\");\n\n        SmartWallet wallet = new SmartWallet(address(this), msg.sender, address(this));\n        cw.addSpace(spaceID, address(wallet));\n        walletToCreator[address(wallet)] = msg.sender;\n\n        emit WalletCreated(msg.sender, address(wallet));\n        return address(wallet);\n    }\n\n    function executeForwardTransfer(address payable walletAddress, address token, uint256 amount) external onlyController {\n        address creator = walletToCreator[walletAddress];\n        require(creator != address(0), \"Not a valid wallet\");\n\n        SmartWallet(walletAddress).forwardTransfer(token, amount, creator);\n    }\n\n    // Allowed assets management\n    function addAllowedAsset(address token) external onlyController {\n        allowedAssets[token] = true;\n        emit AllowedAssetAdded(token);\n    }\n\n    function removeAllowedAsset(address token) external onlyController {\n        allowedAssets[token] = false;\n        emit AllowedAssetRemoved(token);\n    }\n\n    function isAllowedAsset(address token) external view returns (bool) {\n        return allowedAssets[token];\n    }\n\n    // Platform fee management\n    function setPlatformFee(uint256 fee) external onlyController {\n        require(fee <= 100, \"Fee too high\");\n        platformFee = fee;\n        emit PlatformFeeUpdated(fee);\n    }\n\n    function getPlatformFee() external view returns (uint256) {\n        return platformFee;\n    }\n \n    function getPlatformWallet() external view returns (address) {\n      return platformWallet;\n    }\n\n}\n\n"
      }
    }
  }
}