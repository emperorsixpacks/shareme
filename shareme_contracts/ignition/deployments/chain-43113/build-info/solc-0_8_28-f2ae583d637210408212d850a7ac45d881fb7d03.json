{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-f2ae583d637210408212d850a7ac45d881fb7d03",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SmartWallet.sol": "project/contracts/SmartWallet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SmartWallet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nstruct CreatorSpace {\n    bytes32 spaceId;\n    address wallet;\n}\n\nstruct CreatorWallets {\n    CreatorSpace[] spaces;\n}\n\nlibrary CreatorWalletsLib {\n    function addSpace(\n        CreatorWallets storage self,\n        bytes32 spaceId,\n        address wallet\n    ) internal {\n        self.spaces.push(CreatorSpace({spaceId: spaceId, wallet: wallet}));\n    }\n\n    function getSpaceById(\n        CreatorWallets storage self,\n        bytes32 spaceId\n    ) internal view returns (CreatorSpace storage) {\n        for (uint256 i = 0; i < self.spaces.length; i++) {\n            if (self.spaces[i].spaceId == spaceId) {\n                return self.spaces[i];\n            }\n        }\n        revert(\"Space not found\");\n    }\n\n    function spaceCount(\n        CreatorWallets storage self\n    ) internal view returns (uint256) {\n        return self.spaces.length;\n    }\n\n    function hasSpace(\n        CreatorWallets storage self,\n        bytes32 spaceId\n    ) internal view returns (bool) {\n        for (uint256 i = 0; i < self.spaces.length; i++) {\n            if (self.spaces[i].spaceId == spaceId) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract SmartWallet {\n    address private controller;\n    address public creator;\n    address public platformWallet;\n\n    uint256 public platformFee = 20; // 20%\n    mapping(address => bool) public allowedAssets;\n\n    event PaymentReceived(address sender, uint amount);\n    event PaymentSplit(\n        address creator,\n        uint creatorAmount,\n        uint platformAmount\n    );\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"Not controller\");\n        _;\n    }\n\n    constructor(\n        address _controller,\n        address _creator,\n        address _platformWallet\n    ) {\n        controller = _controller;\n        creator = _creator;\n        platformWallet = _platformWallet;\n    }\n\n    function forwardTransfer(\n        address token,\n        uint256 amount\n    ) external onlyController {\n        require(allowedAssets[token], \"Token not allowed\");\n        require(amount > 0, \"No payment\");\n\n        uint256 platformAmount = (amount * platformFee) / 100;\n        uint256 creatorAmount = amount - platformAmount;\n\n        require(\n            IERC20(token).transfer(creator, creatorAmount),\n            \"Creator transfer failed\"\n        );\n        require(\n            IERC20(token).transfer(platformWallet, platformAmount),\n            \"Platform transfer failed\"\n        );\n\n        emit PaymentReceived(msg.sender, amount);\n        emit PaymentSplit(creator, creatorAmount, platformAmount);\n    }\n\n    function addAllowedAsset(address _token) external onlyController {\n        allowedAssets[_token] = true;\n    }\n\n    function removeAllowedAsset(address _token) external onlyController {\n        allowedAssets[_token] = false;\n    }\n\n    function updatePlatformFee(uint256 newFee) external onlyController {\n        platformFee = newFee;\n    }\n\n    // function getBalance(address token) external view returns (uint256) {\n    //     require(!allowedAssets(address), \"Address not Supported\")\n    //     return IERC20(token).balanceOf(address(this));\n    // }\n\n    receive() external payable {\n        uint256 platformAmount = (msg.value * platformFee) / 100;\n        uint256 creatorAmount = msg.value - platformAmount;\n\n        payable(creator).transfer(creatorAmount);\n        payable(platformWallet).transfer(platformAmount);\n\n        emit PaymentReceived(msg.sender, msg.value);\n        emit PaymentSplit(creator, creatorAmount, platformAmount);\n    }\n}\n\ncontract SmartWalletFactory {\n    address public platformWallet;\n\n    using CreatorWalletsLib for CreatorWallets;\n    mapping(address => CreatorWallets) private creatorWallets;\n\n    event WalletCreated(address indexed creator, address wallet);\n\n    constructor(address _platformWallet) {\n        platformWallet = _platformWallet;\n    }\n\n    function createWallet(bytes32 spaceID) external returns (address) {\n        CreatorWallets storage cw = creatorWallets[msg.sender];\n        require(!cw.hasSpace(spaceID), \"Space already exists\");\n\n        SmartWallet wallet = new SmartWallet(\n            platformWallet,\n            msg.sender,\n            platformWallet\n        );\n\n        cw.addSpace(spaceID, address(wallet));\n\n        emit WalletCreated(msg.sender, address(wallet));\n        return address(wallet);\n    }\n}\n"
      }
    }
  }
}